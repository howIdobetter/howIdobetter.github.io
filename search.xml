<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cs168-textbook6</title>
      <link href="/2026/01/20/cs168-textbook6/"/>
      <url>/2026/01/20/cs168-textbook6/</url>
      
        <content type="html"><![CDATA[<h1 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h1><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>Bandwidth带宽链路的最大数据传输速率（Bits per second）。<br>Propagation Delay传播延迟信号在介质中从发送端传输到接收端所需的时间。<br>Bandwidth-Delay Product (BDP)带宽延迟积衡量链路“在途”数据的最大容量（$BDP &#x3D; \text{Bandwidth} \times \text{Delay}$）。<br>Latency时延&#x2F;延迟泛指从发送到接收的时间差，受传播、排队、处理等多种因素影响。<br>Timing Diagram时序图描述协议实体间随时间交互的图表。<br>Transmission Delay传输延迟将所有比特推向传输介质所需的时间（$L&#x2F;R$）。<br>Propagation Delay传播延迟电磁信号在介质中跨越物理距离所需的时间（$D&#x2F;S$）。<br>End-to-End Delay端到端延迟数据包从离开源到完全到达目的地经历的总时间。<br>Serialization串行化将数据结构转换为比特流并逐一发送的过程。</p><h2 id="链路及其属性"><a href="#链路及其属性" class="headerlink" title="链路及其属性"></a>链路及其属性</h2><p>既然我们已经对互联网的分层架构有了初步了解，现在让我们专注于数据包是如何跨越**链路（Link）**进行传输的。我们可以使用三个属性来衡量链路的性能。</p><p>链路的**带宽（Bandwidth）**告诉我们单位时间内可以在链路上发送多少比特。直观地说，这就是链路的“速率”。如果把链路比作输水管，带宽就是水管的宽度。更宽的水管允许我们每秒向其中注入更多的水。我们通常以“比特每秒”为单位衡量带宽（例如：5 Gbps &#x3D; 每秒 50 亿比特）。</p><p>链路的**传播延迟（Propagation Delay）**告诉我们一个比特在链路上行程所需的时间。在水管类比中，这相当于水管的长度。较短的水管意味着水在到达另一端之前，在管中停留的时间更短。传播延迟以时间为单位（如：纳秒、毫秒）。</p><p>如果我们将带宽与传播延迟相乘，就会得到带宽延迟积（Bandwidth-Delay Product, BDP）。直观上，这是链路的“容量”，即在任何给定瞬间，存在于链路上的比特总数。在水管类比中，如果我们注满水管并冻结时间，水管的容量就是那一瞬间管子里水的总量。</p><p><img src="/image/cs168-textbook6/1768912287536.png" alt="1768912287536"></p><p>注： 你有时可能会看到**时延（Latency）**这个术语。在单条链路的语境下，时延指的就是其传播延迟；但该词也可用于其他语境（例如：跨越多条链路的端到端延迟）。“Latency”本身没有严格的正式定义，其含义取决于具体语境。</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>假设我们有一条带宽为 1 Mbps（即每秒 100 万比特）、传播延迟为 1 ms（即 0.001 秒）的链路。</p><p>我们想通过这条链路发送一个 100 字节（即 800 比特）的数据包。从发送第一个比特开始，到接收到最后一个比特为止，总共需要多长时间？</p><p>为了回答这个问题，我们可以画一张时序图（Timing Diagram）。左侧的垂直线代表发送方，右侧代表接收方。时间从 0 开始，随着图表向下移动而增加。</p><p><img src="/image/cs168-textbook6/1768912837921.png" alt="1768912837921"></p><p>让我们先关注第一个比特。由于带宽允许每秒发送 1,000,000 个比特，因此将单个比特推上链路需要 $1&#x2F;1,000,000 &#x3D; 0.000001$ 秒。在第 0.000001 秒时，链路上已经有了一个比特，位于发送端。<br>随后，这个比特需要 0.001 秒在链路上传输（传播延迟），因此在 $0.000001 + 0.001$ 秒时，第一个比特到达接收方。<br><img src="/image/cs168-textbook6/1768912759443.png" alt="1768912759443"></p><p>现在让我们考虑最后一个比特。如前所述，放一个比特到链路上需要 0.000001 秒。我们总共有 800 个比特要发送，因此最后一个比特在 $800 \times 0.000001 &#x3D; 0.0008$ 秒时被放置到链路上。</p><p>接着，最后一个比特也需要 0.001 秒在链路上传输，因此在 $0.0008 + 0.001$ 秒时，最后一个比特到达接收方。这就是我们说数据包“到达”接收方的时间点。</p><p><img src="/image/cs168-textbook6/1768912804037.png" alt="1768912804037"></p><h2 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h2><p>更广泛地说，分组延迟（Packet Delay）是指发送整个数据包所需的时间——从第一个比特被推上信道（Wire）开始，直到最后一个比特在另一端被接收为止。该延迟是传输延迟（Transmission Delay）与传播延迟（Propagation Delay）的总和。</p><p>传输延迟告诉我们把所有比特放置到信道上需要多长时间。在前面的例子中，计算方式是 $800 \cdot (1&#x2F;1,000,000)$。通常情况下，传输延迟等于数据包大小（Packet Size）除以链路带宽（Link Bandwidth）。</p><p>由于传输延迟是带宽的函数，我们可以根据带宽和传播延迟这两个链路属性，来计算出最终的分组延迟。</p><h2 id="带宽和传播延迟的权衡"><a href="#带宽和传播延迟的权衡" class="headerlink" title="带宽和传播延迟的权衡"></a>带宽和传播延迟的权衡</h2><p>考虑以下两条链路：</p><p>链路 1： 带宽 10 Mbps，传播延迟 10 ms。</p><p>链路 2： 带宽 1 Mbps，传播延迟 1 ms。</p><p>哪条链路更好？这取决于你发送的数据包。</p><p>假设我们要发送一个单个 10 字节的小包。对于这两条链路而言，将数据包推上信道的时间（传输延迟）几乎可以忽略不计，传播延迟是延迟的主要来源。由于链路 2 的传播延迟更短，因此它是更好的选择。</p><p>相反，假设我们要发送一个单个 10,000 字节的大包。此时，传输延迟成为了延迟的主要来源。我们更倾向于选择链路 1，因为它拥有更高的带宽，能让我们更快地将字节推上信道。你可以通过正式的分组延迟公式验证这一直觉：链路 1 发送该包大约需要 18 ms，而链路 2 则需要大约 81 ms。</p><p>举个现实世界的例子：视频通话。如果视频画质很差（模糊、马赛克），通常是因为带宽不足（此时缩短传播延迟也无济于事）。相比之下，如果你说话之后要等很久对方才有反应（音画不同步或明显的交谈停顿），通常是因为传播延迟太长（此时增加带宽也无法改善）。</p><h2 id="管道图"><a href="#管道图" class="headerlink" title="管道图"></a>管道图</h2><p>到目前为止，我们一直在通过画时序图来标记网络事件发生的时间点（例如接收方何时收到数据包）。</p><p>另一种观察数据包跨网络传输的方法是：在某个冻结的时间点，画出链路上比特的分布情况。这两种视角传达的信息是一致的，但取决于具体语境，某种视角可能比另一种更有用。</p><p>为了描绘链路，我们可以将链路想象成一根管道（类似于水管类比），并将其画成一个长方形：宽度代表传播延迟，高度代表带宽。长方形的面积则代表链路的容量。</p><p><img src="/image/cs168-textbook6/1768913827534.png" alt="1768913827534"></p><p>假设我们要通过链路发送一个 50 字节的数据包。在管道视角下，我们可以展示数据包在链路上移动的冻结瞬间。数据包被排列成一个矩形，其高度告诉我们在单个时间步内有多少字节被推上信道。在每个时间步，数据包在管道中向右滑动。最终，数据包开始离开管道，且在每个时间步中，矩形的一列数据会退出管道。</p><p><img src="/image/cs168-textbook6/1768913871442.png" alt="1768913871442"></p><p><img src="/image/cs168-textbook6/1768913879198.png" alt="1768913879198"></p><p><img src="/image/cs168-textbook6/1768913886312.png" alt="1768913886312"></p><p>一个非直观的事实： 时序图中的分组传输延迟对应于管道图中数据包矩形的宽度。</p><p>为了理解这一点，假设有一条带宽为 5 bps（每秒 5 比特）的链路，我们要发送一个 20 比特的数据包。在时序图中，从发送第一个比特到发送最后一个比特之间有 4 秒的时间。</p><p><img src="/image/cs168-textbook6/1768913911899.png" alt="1768913911899"></p><p>在管道图中，每一秒都有由 5 个比特组成的一列“行进”进入管道。我们需要 4 列才能全部进入，这需要 4 秒。这意味着数据包在管道中的宽度就是 4 列数据包，即 4 秒。</p><p><img src="/image/cs168-textbook6/1768913941015.png" alt="1768913941015"></p><p>管道图允许我们在同一坐标轴上观察分组传输时间和传播延迟，并将这两项进行对比。</p><p><img src="/image/cs168-textbook6/1768913979669.png" alt="1768913979669"></p><p>管道图在比较不同链路时非常有用。让我们看看相同的数据包在三种不同链路中的表现：</p><ol><li><strong>缩短传播延迟：</strong> 管道的宽度变窄。管道的高度保持不变，每个矩形数据包的形状也不变。（记住，你可以把数据包的高度看作每个时间步进入管道的比特数，宽度看作将所有比特推入管道所需的时间。）<ul><li><strong>观察结果：</strong> 数据包宽度不变，意味着传输延迟没有改变。此外，链路面积减小，说明链路容量降低了。</li></ul></li><li><strong>增加带宽：</strong> 管道的高度变高，表明单位时间内我们可以将更多比特推入管道。<ul><li><strong>观察结果：</strong> 数据包的形状也发生了变化。数据包现在变得 <strong>更高</strong> ，因为单位时间内推入的比特更多。结果，我们完成填充数据包的速度大大加快，因此数据包的 <strong>宽度（传输延迟）减小了</strong> 。</li></ul></li></ol><h2 id="过载链路"><a href="#过载链路" class="headerlink" title="过载链路"></a>过载链路</h2><p><img src="/image/cs168-textbook6/1768914400497.png" alt="1768914400497"></p><p>请想象数据包到达交换机的场景。交换机需要将所有收到的包转发到输出链路上。如果交换机拥有足够的容量来处理每一个到达的包，那么一切正常。</p><p><img src="/image/cs168-textbook6/1768914431865.png" alt="1768914431865"></p><p>但如果是下面这种情况呢？</p><p><img src="/image/cs168-textbook6/1768914449097.png" alt="1768914449097"></p><p>从长远来看，我们有足够的容量发送所有输出包；但在当前的特定瞬间，有两个包同时到达，而我们只能发送一个。这被称为 <strong>瞬时过载（Transient Overload）</strong> ，在互联网交换机中极其常见。<br>为了应对瞬时过载，交换机会维护一个 <strong>分组队列（Queue of packets）</strong> 。如果两个包同时到达，交换机会将其中一个排入队列，并发送另一个。</p><p><img src="/image/cs168-textbook6/1768914472353.png" alt="1768914472353"></p><p>在任何给定时刻，交换机可以选择从某个输入链路发送包，或者发送队列中的包。这一选择由**分组调度（Packet Scheduling）**算法决定，我们将研究许多不同的算法设计。</p><p><img src="/image/cs168-textbook6/1768914501787.png" alt="1768914501787"></p><p>当没有输入包进入时，交换机可以清空队列，发送之前缓存的所有包。</p><p><img src="/image/cs168-textbook6/1768915077875.png" alt="1768915077875"></p><p>这使得队列能帮助我们吸收 <strong>瞬时突发流量（Transient Bursts）</strong> 。</p><p><img src="/image/cs168-textbook6/1768915096501.png" alt="1768915096501"></p><p>如果输入链路的情况变成下面这样呢？</p><p><img src="/image/cs168-textbook6/1768915139267.png" alt="1768915139267"></p><p>现在我们面临的是 <strong>持续过载（Persistent Overload）</strong> 。输出链路的容量根本无法支撑如此高水平的输入流量。<br>我们可以填满队列，但这仍然不足以支撑输入负载。无论如何，交换机最终都会 <strong>丢包（Drop packets）</strong> 。</p><p>我们该如何解决持续过载？网络运营商需要合理地<strong>配置（Provision）<strong>他们的链路和交换机。如果发现某台交换机频繁过载，他们可能会决定升级链路（这可能需要人工部署）。<br>解决过载的一个可能方案是让路由器通知发送方减慢速度（我们稍后在学习</strong>拥塞控制</strong>时会研究这一点）。但归根结底，我们并没有太多办法彻底解决过载，这也是为什么互联网被设计为仅提供**尽力而为（Best-effort Service）**服务的原因。</p><p>现在我们有了队列的概念，需要回头更新我们的分组延迟公式。现在，<strong>分组延迟等于传输延迟、传播延迟与排队延迟之和。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> ~~~///(^v^)&#92;&#92;&#92;~~~ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs168-textbook5</title>
      <link href="/2026/01/15/cs168-textbook5/"/>
      <url>/2026/01/15/cs168-textbook5/</url>
      
        <content type="html"><![CDATA[<h1 id="Designing-Resource-Sharing"><a href="#Designing-Resource-Sharing" class="headerlink" title="Designing Resource Sharing"></a>Designing Resource Sharing</h1><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>Statistical Multiplexing统计复用基于概率统计的资源共享。利用“大家不会同时用满带宽”的概率来超卖资源。</p><p>Peak Demand峰值需求用户在最高负载时刻需要的带宽。</p><p>Packet Switching分组交换互联网的基石。数据被切成“分组”，像无名包裹一样在路上挤着走。</p><p>Circuit Switching电路交换电话网的遗产。先修路，再开车；路修好了，别人就不能用这条车道。</p><h2 id="资源共享：统计复用"><a href="#资源共享：统计复用" class="headerlink" title="资源共享：统计复用"></a>资源共享：统计复用</h2><p>互联网上的链路和交换机容量是有限的。我们需要解决的一个关键设计问题是：如何由不同的互联网用户共享这些资源？</p><p>让我们把问题形式化：回想一下，“流（Flow）”是两个端主机之间交换的数据包序列（例如你和朋友之间的视频通话）。尽管容量有限，互联网仍需要同时支持许多并发流。</p><p><img src="/image/cs168-textbook5/1768460709562.png" alt="1768460709562"></p><p>我们常说网络资源是统计复用的，这意味着我们会根据用户的需求动态分配资源，而不是为用户划分固定的资源份额。</p><p><img src="/image/cs168-textbook5/1768460728302.png" alt="1768460728302"></p><p>举个类比：考虑你的个人电脑。电脑并不会预先为 Firefox 分配一半 CPU，为 Zoom 分配另一半，且只允许每个应用使用那一半。相反，你的电脑会根据不同应用的需求动态分配资源。</p><p>统计复用在计算机科学中无处不在。例如在云计算中，不同公司可能会动态共享数据中心资源。</p><p>统计复用是高效共享网络资源的一种绝佳方式，因为用户的需求随时间而变化。你可能不会在 24 小时内的每一秒都保持恒定的 10 Mbps 带宽需求。你清醒时的需求可能更多，睡眠时则较少。</p><p>让统计复用发挥作用的前提是：在实践中，总需求的峰值远小于各项需求峰值的总和。</p><p>让我们拆解一下其中的含义。假设有两个用户 A 和 B。我们可以绘制每个用户随时间变化的需求图。</p><p><img src="/image/cs168-textbook5/1768460794150.png" alt="1768460794150"></p><p>为了完全满足两个用户的需求，我们需要分配多少容量？</p><p>糟糕的策略（非统计复用）是计算“各项需求峰值的总和”。我们找到 A 的峰值需求和 B 的峰值需求，然后将它们相加。如果我们分配这么大的容量，肯定能满足需求。A 的峰值是 $X$，我们分给 A 长度为 $X$ 的专属带宽，同理分给 B 长度为 $Y$ 的。然而，这种方法很浪费，因为 A 的峰值和 B 的峰值并没有在同一时间发生。</p><p><img src="/image/cs168-textbook5/1768460817100.png" alt="1768460817100"></p><p><img src="/image/cs168-textbook5/1768460835246.png" alt="1768460835246"></p><p>更好的策略（统计复用）是首先通过绘制两个用户随时间变化的合并需求图来计算“总需求”。例如，新图表中上午 10 点的需求等于 A 的 10 点需求加上 B 的 10 点需求。然后，我们计算这个总需求的峰值。</p><p><img src="/image/cs168-textbook5/1768460876613.png" alt="1768460876613"></p><p>如果我们只分配这么大的容量，我们就不能再静态地为每个用户分配固定部分。然而，通过随时间动态改变分配给每个用户的量，我们仍然可以成功满足他们的需求，即使总容量更小。</p><p><img src="/image/cs168-textbook5/1768460885093.png" alt="1768460885093"></p><p>统计复用允许我们用更小的容量支持同样多的用户（成本更低，资源利用率更高）。对于许多分布情况，我们可以证明总需求的峰值实际上更接近平均需求之和，这远小于峰值需求之和。</p><p>在实践中，网络并不会针对“所有事情同时达到峰值”的最坏情况进行准备。相反，我们动态共享资源，并寄希望于峰值不会同时发生。峰值确实仍可能同时发生，这会导致数据包延迟或丢弃（回想一下链路队列）。尽管如此，我们还是选择了统计复用以提高资源利用率，并承担相应的后果（偶尔出现的并发峰值）。</p><p>归根结底，统计复用是一个带有权衡的设计选择。不同的用户可能会有不同的选择。例如，金融交易所交易时有时会决定建立自己的专用网络来支撑峰值需求，因为他们更在意确保高峰期间的连通性，且能承担额外成本。</p><h2 id="资源共享：电路交换vs-分组交换"><a href="#资源共享：电路交换vs-分组交换" class="headerlink" title="资源共享：电路交换vs.分组交换"></a>资源共享：电路交换vs.分组交换</h2><p>我们现在知道可以使用统计复用来决定建设多少容量。接下来的问题是：我们如何真正地在用户之间动态分配资源？</p><p>举个类比：想象一家拥有众多顾客但桌位有限的热门餐厅。我们可以想象两种分配桌位的方法：一是让顾客进行预约（Reservations），二是按**先到先得（First-come first-serve）**的原则安排座位。</p><p>网络中共享资源的两种方法与之类似。一种方法是尽力而为（Best-effort）。每个人都直接将数据发送到网络中，不进行任何预约，并寄希望于一切顺利。这种方式不保证有足够的带宽来满足你的需求。</p><p>尽力而为模式的典范设计被称为分组交换（Packet Switching）。交换机独立地处理每一个数据包，并将其转发到离目的地更近的地方。交换机不考虑“流”或“预约”。除了数据包之间相互独立外，交换机之间也是相互独立的。当一个数据包跨越多个交换机跳转时，每个交换机都独立地处理该包（交换机之间不进行协作）。</p><p><img src="/image/cs168-textbook5/1768461172684.png" alt="1768461172684"></p><p>另一种方法基于预约（Reservations）。在“流”开始时，用户明确请求并预约所需的带宽。数据发送完毕后，资源可以释放供他人预约。</p><p>预约模式的典范设计（在研究界和工业界均有探索）被称为电路交换（Circuit Switching）。在“流”开始时，端主机通过某种路由算法识别出穿过网络的一条路径（一系列交换机和链路）。然后，源端向目的地发送一条特殊的预约请求消息。沿途的每个交换机都会收到这个请求。如果每个交换机都接受了请求，那么预约成功，源端和目的地之间就建立了一套交换机“电路”。</p><p><img src="/image/cs168-textbook5/1768461202235.png" alt="1768461202235"></p><p>一旦每个交换机都确认了预约，数据就可以发送了。最终，当流结束时，源端向接收方发送一条拆除（Teardown）消息。沿途每个交换机看到此消息后便释放其容量。</p><p><img src="/image/cs168-textbook5/1768461209517.png" alt="1768461209517"></p><p>注：我们在这里使用“电路（Circuit）”一词，是因为这个创意源自电话网络，电话网正是利用这一理念让两人互相通话。</p><p>请记住，电路交换和分组交换都体现了统计复用。主要区别在于我们分配资源的粒度：是针对每个“流”进行预约，还是针对每个“包”尽力而为。即使在电路交换中，我们也是根据预约动态分配资源的，而不是预先为所有可能存在的流保留资源。</p><p><img src="/image/cs168-textbook5/1768461222984.png" alt="1768461222984"></p><h2 id="电路交换vs-分组交换：权衡与取舍"><a href="#电路交换vs-分组交换：权衡与取舍" class="headerlink" title="电路交换vs.分组交换：权衡与取舍"></a>电路交换vs.分组交换：权衡与取舍</h2><p>现在我们有了两种共享互联网资源的方法。哪种更好？这取决于我们用来评估每种方法的标准。我们可以从四个维度来比较这两种方法。</p><p>目前，我们在互联网上共享资源有两种主要方式。哪种更好？这取决于我们评估时所采用的维度。我们可以从以下四个维度对这两种方法进行对比。</p><ol><li>抽象能力与 API (Abstraction&#x2F;API)<br>这对应用程序开发者来说，是否是一个良好的网络抽象？</li></ol><p>电路交换为开发者提供了更有用的抽象，因为它能提供带宽预留 (Reserved Bandwidth) 的保证。这为开发者带来了更具可预测性且易于理解的网络行为（在一切运行正常的前提下）。</p><p>类比：这就像在云端预留一台机器来运行任务。如果开发者清楚所获机器的具体规格，就更容易推算性能。反之，如果开发者不知道使用的是什么机器，任务虽能运行，但性能却难以预测。</p><p>运营商视角：对于需要向用户分配资源的运营商来说，电路交换也是一种有用的抽象。你可以精确获知每个用户请求的带宽量，并据此计费。如果没有服务质量保证，很难建立直观的商业模式。</p><ol start="2"><li>规模化效率 (Efficiency at Scale)<br>这种方法在大规模应用时是否高效？它能利用网络中的所有可用带宽，还是会造成带宽浪费？</li></ol><p>分组交换（也称包交换）通常效率更高，具体领先多少取决于流量源的突发性 (Burstiness)。</p><p>恒定速率：如果每个发送者始终以恒定速率发送数据，那么电路交换和分组交换都能充分利用带宽。</p><p><img src="/image/cs168-textbook5/1768462028125.png" alt="1768462028125"></p><p>可变速率（突发流量）：如果发送者的速率随时间波动，分组交换的带宽利用率更高。</p><p><img src="/image/cs168-textbook5/1768462037993.png" alt="1768462037993"></p><p>示例说明：假设总带宽为 30 Mbps。在预留机制下，三个流分别请求预留 12、11 和 13 Mbps。由于总量限制，其中一个请求将被拒绝。</p><p>这种做法在两方面浪费了带宽：首先，预留了 12 Mbps 的流在大部分时间内并未实际占满带宽；其次，如果 12 Mbps 和 11 Mbps 的流获得了预留，剩下的 7 Mbps 处于空闲状态，无人使用。</p><p>分组交换对比：在分组交换中，数据包随到随发，只要任意时刻的总带宽需求不超过 30 Mbps，我们就能利用现有带宽支撑所有流。</p><p>关键概念：突发比 (Burstiness Ratio) 定义为峰值速率与平均速率的比值。</p><p>语音通话：通常比例较低（如 3:1），较为平滑（这也是为什么传统电话网采用预留机制）。</p><p>网页浏览：通常具有极高的突发性（如 100:1）。</p><p>开销问题：分组交换更高效的另一个原因是：电路交换需要额外的建立和拆除连接 (Setup and Teardown) 的时间，这对于短连接流量（如下载小文件）来说效率极低。</p><ol start="3"><li>规模化失效处理 (Failure at Scale)<br>在大规模环境下，每种方法处理故障的能力如何？</li></ol><p>分组交换在处理大规模故障方面表现更佳。如果某个路由器故障，我们只需将数据包通过网络中的另一条路径发送即可（路由算法非常擅长自动适应故障）。终端主机无需做出任何改变。</p><p>相比之下，在电路交换中，如果路径上的路由器发生故障，尽管网络仍需寻找新路径，但终端主机的负担更重：</p><p>主机必须检测到故障。</p><p>主机必须重新发送预留请求。</p><p>主机还必须设法释放旧路径上的预留资源。</p><p>如果新的预留请求被拒绝了怎么办？</p><p>这种故障模式的扩展性很差：如果一个核心路由器宕机，且有数百万个流正在使用它，那么数百万个预留请求必须同时尝试重新建立。处理电路交换中的失效是一个极其复杂的难题。</p><ol start="4"><li>实现复杂度 (Implementation Complexity)<br>在大规模环境下，实现每种方法的复杂度如何？</li></ol><p>如果你尝试设计电路交换协议，许多额外的设计问题会使协议迅速变得异常复杂：</p><p>确认机制：路由器如何知道预留成功了？当节点 2 同意请求时，它如何确定节点 3 和 4 也同意了？（可能方案：反向发送确认包）。</p><p>丢包处理：如果预留请求在途中丢失了怎么办？（可能方案：设置定时器，超时则删除预留）。</p><p>确认包丢失：如果大家都同意了，但返回的确认包丢了怎么办？</p><p>拒绝策略：如果预留被拒绝，主机是应该降低带宽需求重试，还是稍后原样重试？路由器是否应该在拒绝信息中提供建议（如“我给不了 10M，但我能给你 8M”）？</p><p>核心矛盾：状态共识 (State Consensus) 电路交换复杂的根本原因在于所有路由器都必须维护额外的状态 (State)，并且必须对这些状态达成共识。你可能听说过 Paxos 协议，这是一种极其复杂的分布式共识协议。在实践中，人们通常只在 4-5 台服务器的小集群上运行它。而电路交换本质上是要求在互联网规模（数百万路由器和流）上运行这种共识。</p><p>总结 (Summary)<br>电路交换：通过带宽预留为应用提供更好的性能保证，行为更具可预测性。</p><p>分组交换：提供更高效的带宽共享，避免了启动延迟。它在故障恢复方面更简单，且整体实现复杂度更低（路由器处理负担较轻）。</p><h2 id="实践中的电路交换与分组交换"><a href="#实践中的电路交换与分组交换" class="headerlink" title="实践中的电路交换与分组交换"></a>实践中的电路交换与分组交换</h2><p>在现代互联网中，分组交换 (Packet Switching) 是默认的方案。电路交换 (Circuit Switching) 的应用场景则非常有限。</p><p>现代互联网中的电路交换残余<br>RSVP (资源预留协议)：该协议可用于小型局部网络内部，允许路由器之间（而非终端主机之间）预留带宽。</p><p>专用电路 (Dedicated Circuits)：例如 MPLS 电路或租用专线 (Leased Lines)。企业可以专门购买专属于其业务的互联网带宽（有时甚至包括物理基础设施）。相比标准的互联网连接，这种方式价格极其昂贵。</p><p>规模差异：相比于假设的“全互联网规模”电路交换，专用电路的部署规模要小得多。通常由人工手动完成预留，且预留时间跨度极长（如数年之久）。此外，预留的粒度是以“公司”为单位，而非单个“流量流 (Flow)”。</p><p>简要历史回顾<br>初创期 (1970s-1980s)：当互联网还是一个由政府资助的小规模研究项目时，它就采用了分组交换技术。</p><p>商业化时期 (1990s)：随着政府停止资助，互联网控制权移交给商业机构，学术界和工业界曾一度认为我们需要转型为电路交换。</p><p>预测失误：当时的架构师预测语音通话和电视直播将成为互联网的主要重载应用。这两类应用的带宽需求平滑，非常适合电路交换。</p><p>商业动机：由于互联网服务提供商 (ISP) 必须通过商业化手段盈利，他们认为电路交换能提供更直观、更容易计费的商业模式。</p><p>愿景的幻灭与现状<br>尽管研究机构和标准组织为了实现电路交换付出了巨大努力，但最终这一愿景失败了，原因正如我们之前讨论的那样。此外，推动互联网增长的核心驱动力是电子邮件和网页浏览，而非语音通话和电视，这也是电路交换没能成功的重要原因。</p><p>一个有趣的后果是：用户和开发者已经适应了分组交换的现实。 如果你在观看视频时连接质量变差，你已经习惯了应用程序会自动进行自适应调整（如降低画质）。相比之下，传统的广播电视就无法做到这一点。这是一个技术如何改变用户行为的典型案例！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ~~~///(^v^)&#92;&#92;&#92;~~~ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs168-textbook4</title>
      <link href="/2026/01/15/cs168-textbook4/"/>
      <url>/2026/01/15/cs168-textbook4/</url>
      
        <content type="html"><![CDATA[<h1 id="Network-Architecture"><a href="#Network-Architecture" class="headerlink" title="Network Architecture"></a>Network Architecture</h1><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>SDN (Software-Defined Networking)软件定义网络将路由器的“大脑”（控制面）与“手脚”（数据面）分离，实现云端统一指挥，是现在的技术大趋势。</p><p>Top-down View自顶向下视角从需求、目标和哲学层面审视系统，而非从导线和比特开始。</p><p>Narrow Waist窄腰互联网架构的形态描述。中间层（IP层）协议高度统一，而顶层和底层协议多种多样。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>NTP (Network Time Protocol)网络时间协议用于同步计算机时钟的古老且重要的协议，保证全球设备时间一致。</p><p>Protocol Stack协议栈层级协议的组合方式。例如 Web 开发常说的 TCP&#x2F;IP 协议栈。</p><h2 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h2><p>到目前为止，我们采用了“自底向上”的视角来观察互联网，即从基础组件开始，逐步构建出整体图景。在本节中，我们将采用“自顶向下”的视角，分析其设计中的宏观架构选择。</p><p>这些互联网设计范式影响了互联网的运作方式，也影响了我们在其之上构建的应用程序。这些范式是对历史上系统构建方式的一次彻底背离。</p><p>这些设计只是众多可能的设计之一，许多选择是在多年前、互联网成长到当前规模之前做出的。其他设计方案确实存在，关于“最佳设计是什么”的辩论也依然在继续。</p><p>例如，互联网最初被设计为联邦制（Federated）（即独立运营商相互协作），但近年来，软件定义网络（SDN）作为一种更中心化的网络管理方式脱颖而出。</p><p>在最初的互联网中，交换机被刻意设计成“愚钝”的，即只负责转发数据而不进行解析。然而，在现代互联网中，攻击者可能会尝试通过洪泛无用数据来压垮交换机，因此交换机可能需要一种检测机制。那些提出“愚钝基础设施”范式的早期互联网设计者，当时并未考虑到这种安全影响。</p><h2 id="窄腰模型"><a href="#窄腰模型" class="headerlink" title="窄腰模型"></a>窄腰模型</h2><p>在特定的层级中可以存在多种协议。例如，在第 7 层，我们可以使用 HTTP 来提供网站服务，或者使用 NTP 来同步系统时钟，两者都构建在相同的互联网基础设施之上。或者，在第 2 层，我们可以使用以太网（Ethernet）进行有线联网，或者使用 Wi-Fi 进行无线联网。</p><p>请注意，尽管在给定的层级上有多个协议，但你可以为你的应用程序指定使用一套特定的协议栈。例如，你可以指定使用“HTTP over TCP over IP”，而不需要使用其他的第 7 层或第 4 层协议。这样，每一个使用你应用程序的人都将使用相同的协议栈。</p><p><img src="/image/cs168-textbook4/1768445644373.png" alt="1768445644373"></p><p>如果你观察这张图表，你会发现第 3 层只有一个协议。这就是实现互联网连通性的“窄腰”。归根结底，互联网上的每个人都必须同意使用 IP 协议，这样数据包才能在互联网中跨网络传输。</p><h2 id="解复用"><a href="#解复用" class="headerlink" title="解复用"></a>解复用</h2><p>TODO write about demultiplexing.</p><p><img src="/image/cs168-textbook4/1768445846802.png" alt="1768445846802"></p><p><img src="/image/cs168-textbook4/1768445857719.png" alt="1768445857719"></p><p><img src="/image/cs168-textbook4/1768445867850.png" alt="1768445867850"></p><p><img src="/image/cs168-textbook4/1768445878676.png" alt="1768445878676"></p><p><img src="/image/cs168-textbook4/1768445886019.png" alt="1768445886019"></p><p>注意命名： 在网络领域，“端口（Port）”一词有两种不同的含义。物理端口（Physical Port）是指你将链路插入交换机的实际物理位置。逻辑端口（Logical Port）则是第 4 层（传输层）首部中的一个数字，用于区分数据包属于哪个应用程序。</p><p><img src="/image/cs168-textbook4/1768445893985.png" alt="1768445893985"></p><p>注： 套接字（Socket） 术语是指一种操作系统（OS）机制，用于将应用程序连接到操作系统内部的网络协议栈。当应用程序打开一个套接字时，该套接字会与一个逻辑端口号相关联。当操作系统接收到数据包时，它会利用端口号将该数据包定向到相关的套接字。</p><p><img src="/image/cs168-textbook4/1768445907073.png" alt="1768445907073"></p><p><img src="/image/cs168-textbook4/1768445913742.png" alt="1768445913742"></p><p><img src="/image/cs168-textbook4/1768445921908.png" alt="1768445921908"></p><h2 id="端到端原则"><a href="#端到端原则" class="headerlink" title="端到端原则"></a>端到端原则</h2><p>为什么我们采用现有的分层结构来设计互联网？为什么只有端主机理解第 4 层和第 7 层，而路由器不需要？</p><p>端到端原则为互联网设计提供了智慧和指导。MIT 科学家、互联网架构委员会成员 David D. Clark 是这一原则的主要贡献者。他的两篇论文——《系统设计中的端到端论点》(1981) 和《DARPA 互联网协议的设计哲学》(1988)——对互联网的设计哲学产生了巨大影响。</p><p>端到端原则引导着关于“网络应该实现哪些功能、不实现哪些功能”的争论。该原则非常广泛且应用众多，但我们将重点关注：我们应该在网络内部实现可靠性（第 4 层），还是仅在端主机实现？</p><p>现在，让我们考虑一个简单的可靠性协议。主机 A 想要发送 10 个数据包给主机 B，因此它发送了编号为 1 到 10 的数据包。目标是让 B 要么接收所有数据包，要么意识到某些数据包丢失并报错（我们暂且忽略错误恢复）。</p><p>如果我们在网络内部实现可靠性，互联网会是什么样子？ 与我们之前的图景不同，现在每个路由器除了第 1、2、3 层外，还必须理解第 4 层。在这种新图景下，中间路由器必须可靠地将数据包发送到下一跳。它必须保证下一跳收到了所有数据包，如果没有，路由器必须重传任何丢失的包。主机不检查是否收到了所有包，而是依赖网络来确保这一点。</p><p><img src="/image/cs168-textbook4/1768446688295.png" alt="1768446688295"></p><p>在这种方法中，主机必须信任网络。如果其中一个路由器有错误（Bug）并丢弃了数据包，主机对此无能为力。</p><p><img src="/image/cs168-textbook4/1768446694924.png" alt="1768446694924"></p><p>另一种方法是端到端方法，即我们不在网络中实现可靠性，而是强制两个端主机来执行可靠性检查。路由器可以丢包，由端主机来验证是否收到了所有包。</p><p><img src="/image/cs168-textbook4/1768446700494.png" alt="1768446700494"></p><p>在端到端方法中，控制权在主机手中。主机可能仍有 Bug 并丢包，但这一次，主机有权自行修复 Bug。更广泛地说，如果你在编写代码，如果你能控制功能的正确性，而不是依赖可能出错（且你无法修复其错误）的其他人，那是更好的。</p><p>考虑到这种对比，如果我们使用第一种方法（依赖网络），如果网络有 Bug，我们实际上无法保证完美的可靠性。端主机可能最终还是得进行一次端到端的检查（就像第二种方案那样）。</p><p>在旧式网络中，每个链路确实都实现了可靠性。然而，正如我们所见，现代互联网在网络内部仅实现**“尽力而为（Best-effort）”**，并遵循端到端原则，强制端主机实现可靠性。</p><p>总结： 某些应用需求必须在端到端实现才能确保正确性。此外，端到端实现已经足够，不需要网络提供额外支持。由于仅靠端到端实现就已足够，增加网络功能会引入不必要的复杂性（和成本），却无法真正帮助我们实现需求。</p><p>请注意，端到端原则并不是一个永远成立的证明或定理。它是一个指导原则和哲学论点，不同的设计者可能会提出支持或反对该原则的不同理由。</p><p>这里有一个端到端原则并非严格规则的例子。尽管该原则建议仅在端主机中实现可靠性，但除了端到端检查外，我们仍可以在网络中添加一些额外的可靠性。如果链路极度不可靠，这可能会很有用。假设 A 和 B 之间有 10 个链路，每个链路有 10% 的失败率。那么每次发送包，它有 65% 的概率被丢弃。然而，如果每个路由器被修改为发送两份数据包副本以增强可靠性，每个链路的失败率仅为 0.1%，现在数据包被丢弃的概率仅为 1%。无线链路有时会实现可靠性，以降低错误率并提高端主机的性能。</p><p>端到端原则也延伸到了其他领域。例如，在安全领域，端到端原则可能认为通信的两个端主机应该在端点加密消息，而不是在网络中间点加密。</p><p>用 Clark 的话来说：“所讨论的功能只有在端点的应用知识和帮助下，才能完整且正确地实现。因此，将该功能作为通信系统本身的一个特性是不可能的。有时，由通信系统提供的该功能的不完整版本，可能作为性能增强是有用的。”</p>]]></content>
      
      
      
        <tags>
            
            <tag> ~~~///(^v^)&#92;&#92;&#92;~~~ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs168-textbook3</title>
      <link href="/2026/01/13/cs168-textbook3/"/>
      <url>/2026/01/13/cs168-textbook3/</url>
      
        <content type="html"><![CDATA[<h1 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h1><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>Checksum : 校验和。数据完整性的守护者。通过数学算法计算数据的特征值，接收方比对该值以判断数据是否中途被电磁干扰篡改。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>Headers : 首部&#x2F;报头。附加在数据包前面的控制信息。它包含了网络设备处理该包所需的“元数据”（Metadata）。<br>Network Infrastructure : 网络基础设施。指路由器、交换机等中间设备。它们是“搬运工”，不应干涉“货物”内容。<br>Destination Address : 目的地址。网络层的“导航坐标”。路由器查表（Routing Table）时唯一关心的关键字段。<br>Peer &#x2F; Peer Entity对等方 &#x2F; 对等实体指在不同机器上运行的同一个协议层。例如，你手机里的 TCP 协议和服务器里的 TCP 协议互为“对等方”。<br>Horizontal Logic : 横向逻辑逻辑上，L4 只和 L4 说话，L3 只和 L3 说话。<br>Vertical Service : 纵向服务物理上，数据必须经过下层的包裹和搬运才能送达。</p><h2 id="为什么我们需要报头（首部）"><a href="#为什么我们需要报头（首部）" class="headerlink" title="为什么我们需要报头（首部）"></a>为什么我们需要报头（首部）</h2><p>在上一节中，我们了解到在第 3 层，数据以“数据包（Packets）”的形式在互联网中传输。假设一个应用程序想要通过互联网发送一个文件。我们可以提取图像的一部分比特，将它们放入一个数据包中，然后发送出去。然而，当交换机（路由器）接收到这一串 1 和 0 的序列时，它完全不知道该如何处理这些比特。</p><p><img src="/image/cs168-textbook3/1768290014549.png" alt="1768290014549"></p><p>在类比中，如果我给朋友写了一封信并直接递给邮局，邮局完全不知道该拿它怎么办。相反，我们应该把信装进信封，并在信封上写下一些信息（例如朋友的地址），告诉邮局如何处理这封信。</p><p>就像信封一样，当我们发送一个数据包时，我们需要附加额外的元数据（Metadata），告诉网络基础设施如何处理该数据包。这些额外的元数据被称为首部（Header）。其余的比特（例如发送的文件、信封里的信件）被称为有效载荷（Payload）。</p><p><img src="/image/cs168-textbook3/1768290210693.png" alt="1768290210693"></p><p>在类比中，邮局不应该阅读我的信件内容。它应该只阅读信封上的信息，以决定如何寄送我的信件。同样地，网络基础设施也应该只读取首部（Header），以决定如何交付数据。</p><p>收件人关心的是信件内部的内容，而不是信封。同样地，端系统上的应用程序关心的是有效载荷（Payload），而不是首部。尽管如此，端系统仍然需要了解首部，以便在发送数据包之前为其添加首部。</p><h2 id="报头是标准化的"><a href="#报头是标准化的" class="headerlink" title="报头是标准化的"></a>报头是标准化的</h2><p>你也可以将首部看作是发送&#x2F;接收数据的端系统与承载数据的网络基础设施之间的 API。当我们编写软件时，我们需要确定用户与代码交互的接口（例如用户可以调用哪些函数，以及这些函数的参数）。同样，首部中的信息就是用户访问网络功能并传递参数的方式。</p><p>互联网上的每一个人（每一个端系统、每一台交换机）都必须在首部格式上达成一致。如果微软的 Windows 系统修改了其操作系统中的代码，转而发送具有不同首部结构的数据包，那么其他任何人都无法理解这些发出的数据包。</p><p>这也意味着我们在设计首部时必须非常谨慎。一旦我们设计并并在互联网上部署了一个首部，就很难再更改这个设计（因为我们必须让所有人都同意去更改它）。这就是为什么标准制定机构会花费数年时间来设计并标准化首部的原因。</p><h2 id="报头应该包含什么？"><a href="#报头应该包含什么？" class="headerlink" title="报头应该包含什么？"></a>报头应该包含什么？</h2><p>我们应该在首部放入哪些信息？</p><p>首部肯定应该包含目的地址（Destination Address），它告诉我们该将数据包发送到何处。</p><p>首部也可以包含其他非必须但很有用的信息。从技术上讲，**源地址（Source Address）**对于交付数据包并不是必须的，但在实践中，我们几乎总是在首部包含源地址。这使得接收者能够向发送者发送回复。</p><p>首部还可以包含校验和（Checksum），以确保数据包在传输过程中没有损坏。</p><p>首部还可以包含其他元数据，例如数据包的长度（Length）。需要注意的是，数据包的大小是可以变化的（例如，用户可能只需要发送几个字节）。</p><h2 id="多重报头（首部）"><a href="#多重报头（首部）" class="headerlink" title="多重报头（首部）"></a>多重报头（首部）</h2><p>让我们简要回到邮政类比。假设 A 公司的老板想给 B 公司的老板写一封信。这封邮件是如何被发送的呢？</p><p><img src="/image/cs168-textbook3/1768290809197.png" alt="1768290809197"></p><p>A 公司的老板折好信件并将其交给秘书。接着，秘书将信件装入一个信封，并在信封上写下 B 公司老板的全名。</p><p><img src="/image/cs168-textbook3/1768290913731.png" alt="1768290913731"></p><p>秘书将这封信交给收发室。邮政工作人员将信件放入一个写有 B 公司街道地址的箱子中，然后将包裹装上快递车。</p><p><img src="/image/cs168-textbook3/1768290986455.png" alt="1768290986455"></p><p>此时，信件本身被多层标识信息（信封、箱子）包裹着。快递公司将信件发往 B 公司（期间可能经过多辆卡车、飞机、邮递员等）。</p><p><img src="/image/cs168-textbook3/1768291029414.png" alt="1768291029414"></p><p>当信件到达 B 公司时，收发室拆掉箱子，并将信封交给秘书。</p><p><img src="/image/cs168-textbook3/1768291070155.png" alt="1768291070155"></p><p>然后，秘书看到信封上老板的名字，拆掉信封，并将信件呈递给 B 公司的老板。</p><p><img src="/image/cs168-textbook3/1768291103835.png" alt="1768291103835"></p><p>请注意，随着我们向更低的抽象层级移动，我们在数据周围包裹了更多的首部（Headers）。然后，随着我们向更高的抽象层级移动，我们将这些层级从数据中逐层剥离。</p><p><img src="/image/cs168-textbook3/1768291137912.png" alt="1768291137912"></p><p>每一层只需要理解它自己的首部，并且在某种意义上，它正在与位于同一层的对等方（Peers）进行“通信”。当秘书 A 在信封上写下名字时，那是给秘书 B 看的（而不是给邮递员或老板看的）。</p><p>更正式地说，在互联网上，处于同一层级的对等方通过在该层建立“协议”来进行通信。该协议仅对该特定层级的实体有意义。</p><p><img src="/image/cs168-textbook3/1768291258722.png" alt="1768291258722"></p><p>请注意，某些层级提供了多种协议选择（例如第 2 层的无线或有线协议）。在这些情况下，通信的双方需要使用相同的协议选择。有线发送方无法直接与无线接收方进行对话。</p><h2 id="寻址和命名"><a href="#寻址和命名" class="headerlink" title="寻址和命名"></a>寻址和命名</h2><p>早些时候，我们提到首部需要包含接收者的地址。那么，这个地址究竟是什么呢？正式地说， **网络地址（Network Address）**是一个告诉我们主机在网络中所处位置的数值。</p><p>当我们更详细地观察不同的层级时，会发现不同层级拥有不同的寻址方案。如果你想在 Soda Hall（加州大学伯克利分校的一栋建筑）内部寄信，你可以将目的地址写成“Soda Hall 413 室”，楼内的人就知道该把信送到哪里。相比之下，如果你想寄信到纽约，你必须写下一个完整的街道地址，如“纽约州纽约市主街 123 号”。</p><p>同样，互联网中的不同层级也有各自最适合该特定层级的寻址方案。例如，有时主机会通过其人类可读的名称（如 <a href="http://www.google.com)被引用;有时,同一台主机会通过机器可读的/">www.google.com）被引用；有时，同一台主机会通过机器可读的</a> IP 地址（如 74.124.56.2）被引用，这个数字编码了关于服务器位置的信息（且如果服务器移动，该地址可能会改变）；还有些时候，同一台主机可能会通过其硬件 MAC 地址被引用，而这个地址永远不会改变。</p><p><img src="/image/cs168-textbook3/1768291567927.png" alt="1768291567927"></p><h2 id="端系统与路由器中的层次结构"><a href="#端系统与路由器中的层次结构" class="headerlink" title="端系统与路由器中的层次结构"></a>端系统与路由器中的层次结构</h2><p>互联网不仅仅是由发送方和接收方构成的。除了这两个端系统之外，还有路由器负责将数据包跨越多个“跳数”转发至目的地。那么，我们的分层和首部理念在所有这些机器之间是如何交互的呢？</p><p>端系统（End Hosts）需要实现所有层级。你的电脑需要了解第 7 层（应用层）才能运行浏览器；也需要了解第 1 层（物理层）才能将比特通过导线发送出去。你还需要中间的所有层级，以便将应用层数据（老板的信件）一路向下传递到物理层。</p><p>那么**路由器（Routers）**呢？路由器确实需要第 1 层来接收导线上的比特，需要第 2 层来在链路上发送数据包，以及需要第 3 层来在全球网络中转发数据包。然而，路由器并不真的需要考虑第 4 层和第 7 层。路由器并不运行网页浏览器来显示页面，也不需要考虑可靠性（回想一下，它是“尽力而为”的服务模型）。</p><p><img src="/image/cs168-textbook3/1768291733629.png" alt="1768291733629"></p><p>总结：底三层在所有地方都有实现，但顶两层仅在端系统中实现。</p><h2 id="端系统与路由器中的多层首部"><a href="#端系统与路由器中的多层首部" class="headerlink" title="端系统与路由器中的多层首部"></a>端系统与路由器中的多层首部</h2><p>让我们再次思考寄信的过程。A 公司将信件装入信封，然后又将其放入一个箱子中。这个箱子并不会魔术般地直接飞到 B 公司。事实上，它可能会经过好几个邮局。</p><p><img src="/image/cs168-textbook3/1768291849565.png" alt="1768291849565"></p><p>在每个邮局，邮递员都会打开箱子并对邮件进行分拣。邮递员查看信封（打开箱子后显露出的下一层首部），看到信封是发往 B 公司的。</p><p><img src="/image/cs168-textbook3/1768291863191.png" alt="1768291863191"></p><p>接着，邮递员将信封放入另一个箱子中——这个箱子可能与之前的不同——以便信件能够到达前往 B 公司途中的下一个邮局。</p><p><img src="/image/cs168-textbook3/1768291880039.png" alt="1768291880039"></p><p>这个过程在每个邮局不断重复。箱子被打开，露出里面的信封。然后，信封被放入一个新的箱子，前往下一个邮局。请注意，没有任何一个邮局会拆开信封去查看里面的信件，因为他们不需要阅读它。</p><p><img src="/image/cs168-textbook3/1768291933549.png" alt="1768291933549"></p><p>最终，信件装在一个箱子里到达了 B 公司。这一次，B 公司打开了箱子，也拆开了信封，展示出里面的信件。</p><h2 id="端系统与路由器中的多层首部-1"><a href="#端系统与路由器中的多层首部-1" class="headerlink" title="端系统与路由器中的多层首部"></a>端系统与路由器中的多层首部</h2><p>现在我们已经掌握了端系统和路由器的全景图，让我们重新审视数据包在网络中跨越多个“跳数”时，首部包裹与解包的演示。</p><p>首先，主机 A 接收消息并沿协议栈向下处理，依次添加第 7、4、3、2 和 1 层级的首部。现在，我们得到了一个被各层级首部包裹的数据包。第 1 层协议将该包的比特流沿导线发送到前往目的地的第一个路由器。</p><p><img src="/image/cs168-textbook3/1768292047382.png" alt="1768292047382"></p><p>该路由器必须将数据包转发到下一跳，以便数据包最终到达主机 B。我们知道，在全球网络中转发数据包是第 3 层的工作。因此，路由器必须将该数据包解析至第 3 层。路由器读取并拆解第 1 层和第 2 层的首部，露出下方的第 3 层首部。路由器读取该首部以决定接下来的转发路径。</p><p>现在，为了将数据包传送到下一跳，路由器必须再次沿协议栈向下处理，包裹新的第 2 层和第 1 层首部，然后将比特流发送到下一跳的导线上。</p><p><img src="/image/cs168-textbook3/1768292133422.png" alt="1768292133422"></p><p>这一模式在每个路由器上不断重复：第 1 层和第 2 层被拆解以露出第 3 层首部，然后在发送到下一跳之前包裹新的第 2 层和第 1 层首部。请注意，没有任何路由器会查看第 3 层协议以上的内容，因为高层协议仅由端系统进行解析。</p><p><img src="/image/cs168-textbook3/1768292111603.png" alt="1768292111603"></p><p>最终，数据包到达了主机 B，它会逐一拆解每一层：第 1、2、3、4、7 层。主机 B 成功接收到了消息！</p><p><img src="/image/cs168-textbook3/1768292165052.png" alt="1768292165052"></p><p>这种分层方案的一个结果是：每一跳都可以使用不同的第 2 层和第 1 层协议。例如，第一跳可以通过有线发送，主机 A 和第一个路由器使用的初始 L2&#x2F;L1 首部可以是针对有线协议的。相比之下，稍后的某一跳可以通过无线链路发送，该跳两端的路由器使用的 L2&#x2F;L1 首部则可以是针对无线协议的。</p><p><img src="/image/cs168-textbook3/1768292227710.png" alt="1768292227710"></p><p>更广泛地说，我们提到每一层只需要与其同层的对等方进行通信。我们现在可以在所有层级中看到这一点。在第 4 层和第 7 层，两个主机必须使用相同的协议来发送和接收数据包。主机的对等方是另一个主机。</p><p>相比之下，在第 1 层和第 2 层，路由器必须与前一跳和后一跳的路由器使用相同的协议，以便接收和发送数据。路由器的对等方是沿路径与其相邻的路由器。</p><p><img src="/image/cs168-textbook3/1768292266564.png" alt="1768292266564"></p><p>总结：每个路由器解析第 1 层到第 3 层，而端系统解析第 1 层到第 7 层。</p><p><img src="/image/cs168-textbook3/1768292279098.png" alt="1768292279098"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ~~~///(^v^)&#92;&#92;&#92;~~~ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs168-textbook2</title>
      <link href="/2026/01/13/cs168-textbook2/"/>
      <url>/2026/01/13/cs168-textbook2/</url>
      
        <content type="html"><![CDATA[<h1 id="Layers-of-the-Internet"><a href="#Layers-of-the-Internet" class="headerlink" title="Layers of the Internet"></a>Layers of the Internet</h1><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>Bottom-up : 自底向上<br>Infrastructure : 基础设施<br>Pony Express : 小马快递，历史术语，指 19 世纪美国跨州快速邮件传送系统。此处用以类比早期的物理传输介质。<br>Bits : 比特&#x2F;位<br>Optical Fiber : 光纤</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>Physical Layer : 物理层<br>Link Layer : 数据链路层，负责在相邻节点（Node）之间传输数据帧（Frame）。它不关心端到端的路径，只关心“下一跳”怎么走。<br>Internet Layer : 网络层<br>Transport Layer: 传输层。负责主机中进程与进程（Process-to-Process）之间的逻辑通信。<br>Application Layer : 应用层。直接为用户的应用程序提供服务的层，如 HTTP (网页)、SMTP (邮件)、DNS (域名解析)。<br>Session Layer : 会话层。(OSI 第 5 层)负责建立、管理和终止应用程序之间的会话。<br>Presentation Layer : 表示层。(OSI 第 6 层) 负责数据的格式化、加密和压缩（如将二进制转为 JPG 或加密为 TLS）。<br>Wired&#x2F;Wireless : 有线&#x2F;无线。链路层的实现不受物理介质限制。无论是以太网线还是 Wi-Fi，在第二层看来都是一条“链路”。<br>Packets&#x2F;Frames : 分组&#x2F;帧。Frame（帧）是 Layer 2 的官方术语。将连续的比特流加上“头”和“尾”进行定界，就像把散乱的字符装进带封条的信封。<br>ISP (Internet Service Provider) : 互联网服务提供商。为用户提供上网服务的组织（如中国电信、AT&amp;T）。他们是互联网的“庄家”。<br>Router : 路由器。网络的“交通枢纽”。它维护一张路由表，决定数据包前往目的地的“下一跳”地址。<br>Network of Networks : 网络的网络，互联网的定义，它不是一个单一实体，而是由成千上万个自治系统（AS）相互连接而成的集合体。<br>End Hosts : 端系统&#x2F;主机。位于网络边缘、产生或消费数据的设备。它们是网络服务的终点。<br>Modularity : 模块化。将系统分解为可以独立开发和替换的模块。每一层都是一个模块。</p><h2 id="第一层：物理层"><a href="#第一层：物理层" class="headerlink" title="第一层：物理层"></a>第一层：物理层</h2><p>在本节中，我们将自底向上地构建互联网，从最基础的组件开始，逐步将它们组合成互联网的基础设施。我们将使用“邮政系统”作为一个贯穿始终的类比，因为它在许多设计选择上与互联网高度相似。</p><p>首先，我们需要某种方式跨越空间发送信号。在邮政系统中，这可以是邮递员、小马快递、卡车或者信鸽等。</p><p>在互联网中，我们寻找的是一种能跨越空间传输“比特（1和0）”的方法。这种技术可以是电线上的电压、无线电波、光纤电缆中的光脉冲等等。虽然电子工程领域有专门的研究方向致力于信号的跨空间传输，但本课程不会深入探讨这些细节。</p><h2 id="第二层：链路层"><a href="#第二层：链路层" class="headerlink" title="第二层：链路层"></a>第二层：链路层</h2><p>在类比中，既然我们已经有了跨空间发送数据的方法，就可以利用这个基础组件将两户人家连接起来。我们甚至可以尝试将当地的所有房屋都连接在一起。</p><p>在互联网中，一个“链路（Link）”连接着两台机器。这种链路可以使用任何技术（有线、无线、光纤等）。如果我们使用链路将一群邻近的计算机连接起来（例如加州大学伯克利分校的所有电脑），我们就得到了一个局域网（LAN）。</p><p><img src="/image/cs168-textbook2/1768286805348.png" alt="1768286805348"></p><p>在第 2 层，我们还可以将比特（Bits）分组为名为“分组&#x2F;数据包”（Packets，在这一层有时也被称为“帧”）的数据单位，并定义一个包在物理信号中开始和结束的位置。我们还可以处理诸如多个人同时使用同一根导线发送数据等问题。</p><h2 id="第三层：网络层"><a href="#第三层：网络层" class="headerlink" title="第三层：网络层"></a>第三层：网络层</h2><p>我们现在已经有了连接局部地区所有人的方法，但是如果不同地区的两个人想要通信该怎么办呢？一种可能的方法是在不同的本地网络之间增加大量的链路，但这看起来效率不高。（但是如果这两个本地网络在不同的州呢？）</p><p><img src="/image/cs168-textbook2/1768286825054.png" alt="1768286825054"></p><p>相反，一种更加聪明的方法是在每个网络中引入一个“邮局”，并将两个邮局连接起来。现在，如果网络A的人想给网络B的人发信息，他们可以通过邮局寄到网络A的邮局。该邮局将邮件转发给网络B的邮局，再由后者送达到目的地。</p><p><img src="/image/cs168-textbook2/1768286723965.png" alt="1768286723965"></p><p>在互联网中，负责接收并重新定向邮件的“邮局”被称为交换机（switch）或路由器（Router）。如果我们通过在交换机之间建立额外的链路，就可以把各个局域网连接起来。通过足够的链路和局域网，我们可以连接全世界的所有人，从而形成互联网。</p><p><img src="/image/cs168-textbook2/1768286705389.png" alt="1768286705389"></p><p>我们需要回答的一个问题是：如何在网络中寻找路径？当一台交换机收到一个数据包时，它如何知道该往哪里转发，才能让它更接近最终目的地？这将是我们“路由（Routing）”单元的学习重点。我们还需要确保这些链路上有足够的容量来承载数据。这将是我们“拥塞控制（Congestion Control）”单元的学习重点。</p><p>这张图景现在展示了互联网的基础设施。但在本课程中，我们还将研究管理这些基础设施的运营方。在类比中，这些人是建立和管理邮局的人。在互联网上，运营方是互联网服务提供商（ISP），如 AT&amp;T、亚马逊网络服务（AWS），甚至是加州大学伯克利分校，他们拥有并运营着互联网结构。除了硬件和软件基础设施外，我们还需要将这些实体视为现实生活中的商业机构和组织，并考虑他们的经济和政治动机。例如，如果 AT&amp;T 铺设了一条海底光缆，他们可能会向通过该光缆发送数据的其他 ISP 收取费用。</p><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>互联网通常被描述为“网络的网络”。这里有许多小型局域网，其内部事务可以进行本地化管理（例如由加州大学伯克利分校管理）。然后，所有的局域网相互连接，构成了互联网。</p><p>在网络中，不同的链路可能使用不同的第 2 层（Layer 2）技术。有些链路可能使用有线以太网，而其他链路可能使用光纤或无线蜂窝技术。在第 2 层，我们解决的是如何利用该网络特定的技术，在局域网内部的链路上传输数据包。接着，在第 3 层（Layer 3），我们将这种“沿链路发送数据包”的能力作为基础组件，从而实现将数据包发送到互联网的任何地方。当数据包在不同的网络之间“跳跃”时，它可能会通过许多不同类型的链路进行传输。</p><p><img src="/image/cs168-textbook2/1768287931128.png" alt="1768287931128"></p><p>在我们的类比中，我们可以看到“住户”和“邮局”之间的区别。住户之间相互收发信件；而邮局本身并不收发自己的邮件，它们的存在是为了帮助连接其他的住户。</p><p>在互联网中，端系统（End Hosts） 是指通过互联网进行通信的机器（例如服务器、笔记本电脑、手机）。相比之下，交换机（Switch，也称为路由器 Router） 是一种不发送或接收自身数据的机器，它的存在是为了帮助端系统相互通信。交换机的例子包括你家里的路由器，或者是互联网服务提供商（如 AT&amp;T）部署的大型路由器。</p><p>在这些笔记中，我们通常将端系统画成圆圈，将路由器画成方块。</p><h2 id="抽象层级"><a href="#抽象层级" class="headerlink" title="抽象层级"></a>抽象层级</h2><p>随着我们逐步构建互联网，你可能已经注意到，我们一直将复杂的问题分解为更小的任务和“抽象”。</p><p>“基于抽象的模块化是处理问题的方法。”（图灵奖得主芭芭拉·利斯科夫，图灵奖演讲）。这就是我们构建和维护大型计算机系统的方式。模块化对于互联网尤为重要，因为互联网由众多设备（主机、路由器）和许多现实实体（用户、科技公司、ISP）组成，让所有人对任务分配达成共识，是使互联网能够大规模运行的基础。</p><p>这种分层的、“网络的网络”方法的一个主要优点是：每个网络都可以自主决定如何移动数据。例如，当你的数据包在互联网的“跳数”间传输时，某些链路可能使用无线技术，而其他链路可能使用有线技术。底层协议可以在不同的“跳”之间改变，而第 3 层协议依然可以正常工作。</p><p>分层还允许创新并行进行。不同的群体（例如硬件芯片设计师、软件开发人员）可以在不同的层级独立追求创新。</p><h2 id="第三层：尽力而为服务模型"><a href="#第三层：尽力而为服务模型" class="headerlink" title="第三层：尽力而为服务模型"></a>第三层：尽力而为服务模型</h2><p>看起来我们已经构建了一个可以将数据发送到世界任何地方的系统，那为什么不在到此为止呢？关于第 3 层，仍有两个问题需要我们解决。</p><p>第一个问题涉及第 3 层的服务模型。如果你利用第 3 层的基础设施跨互联网发送消息，作为用户的你，网络向你提供的是什么样的服务模型？你可以将服务模型看作是网络与用户之间的一份“合同”，它描述了网络支持什么，以及不支持什么。</p><p>实际服务模型的例子可能包括：网络保证数据送达；或者，网络保证数据在某个时间限制内送达；又或者，网络不保证送达，但承诺在失败时报告错误。</p><p>互联网的设计者没有支持以上任何一种模型。相反，互联网仅支持数据的**尽力而为（Best-effort）**交付。如果你通过第 3 层发送数据，互联网会“尽力”去交付它，但不保证数据一定会被送达。互联网也不会告诉你交付是否成功。</p><p>为什么设计者选择如此“软弱”的服务模型？一个主要原因是：构建能够满足这些较低要求的网络要容易得多。</p><h2 id="第三层：分组-数据包抽象"><a href="#第三层：分组-数据包抽象" class="headerlink" title="第三层：分组&#x2F;数据包抽象"></a>第三层：分组&#x2F;数据包抽象</h2><p>到目前为止，在第 3 层之前，我们一直认为每条消息都是独立通过互联网发送的。更正式地说，第 3 层数据传输的主要单位是数据包（Packet），它是由若干字节组成的一小块数据，作为一个单一单元在互联网中传输，并在路由器之间往返跳转。</p><p>第 3 层的第二个问题是：数据包的大小是有限的。如果应用程序有大量数据需要发送（例如一段视频），我们需要以某种方式将这些数据拆分成多个数据包，并独立地通过网络发送每个包。</p><p>有了这种“数据包抽象”，我们现在可以观察一个数据包穿过网络时的生命周期。发送方将数据拆分为独立的数据包。数据包沿着链路传输并到达一台交换机（路由器）。交换机将数据包转发给目的地，或者转发给另一台离目的地更近的交换机。数据包在一个或多个交换机之间“跳跃”，每一个交换机都将其转发得更近，直到它最终到达目的地。请注意，由于采用的是“尽力而为”模型，任何交换机都可能丢弃该数据包，并且无法保证数据包真正到达目的地。</p><p><img src="/image/cs168-textbook2/1768288744476.png" alt="1768288744476"></p><h2 id="第四层：传输层"><a href="#第四层：传输层" class="headerlink" title="第四层：传输层"></a>第四层：传输层</h2><p>到目前为止，我们已经发现了第 3 层的两个问题：大数据必须拆分为数据包，且 IP 协议仅提供“尽力而为”的服务。</p><p>为了解决这两个问题，我们将引入一个新层级：传输层。该层以第 3 层为基础，并实现了一套额外的协议，用于重传丢失的数据包、拆分数据、以及对乱序到达的数据包进行重新排序（此外还有其他功能）。</p><p>传输层协议让我们不再需要以“数据包”为单位进行思考，而是开始以**“流（Flows）”**的概念进行思考——即在两个端点之间交换的一连串连续的数据包流。</p><h2 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：应用层</h2><p>将应用层构建在互联网之上是一个极其强大的设计选择。如果在底层，我们专门为在端系统之间传输视频构建基础设施，那么电子邮件客户端就必须构建另一套独立的基础设施来传输邮件。互联网的设计使其能够成为一个适用于任何类型应用数据的通用通信网络。</p><p>在本课程中，我们将更多地关注支撑应用层的基础设施（例如邮递员、邮局），而较少关注应用本身（例如邮件的内容）。不过，我们会在课程结束前介绍一些常见的应用层协议。</p><p>现在我们已经了解了所有层级，请注意，每一层都依赖于其直接下层提供的服务，并为其直接上层提供服务。例如，编写第 7 层（应用层）协议的人可以假设他们拥有来自第 4 层的可靠数据传输服务。他们不必担心单个数据包丢失，因为这已经是第 4 层处理过的问题了。</p><p>相邻的两层通过它们之间的接口直接交互。实际上，没有办法跳过层级，比如直接在第 3 层上构建第 7 层。</p><p>注：你可能已经注意到我们跳过了第 5 层和第 6 层。在 20 世纪 70 年代层级首次标准化时，设计者认为这些层是必要的，但在现代互联网中它们已经过时了。如果你感兴趣，会话层（5）原本应该将不同的流组合成一个会话（例如加载各种图像和广告以形成网页），而表示层（6）原本应该帮助用户实现数据可视化。如今，这些层的功能大部分已在第 7 层中实现。</p><p><img src="/image/cs168-textbook2/1768289082361.png" alt="1768289082361"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ~~~///(^v^)&#92;&#92;&#92;~~~ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs168 textbook1</title>
      <link href="/2026/01/12/cs168-textbook1/"/>
      <url>/2026/01/12/cs168-textbook1/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction-to-Internet"><a href="#Introduction-to-Internet" class="headerlink" title="Introduction to Internet"></a>Introduction to Internet</h1><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>ubiquitous : 无处不在的<br>infrastructure : 基础设施<br>World Wide Web : 万维网<br>reasoning about : 对…的考量<br>federate : 联邦式&#x2F;联邦式<br>interoperability : 互操作性<br>innovation paradox : 创新悖论<br>decoupling : 解耦<br>heterogeneity : 异构性<br>orders of magnitude : 数量级<br>outdated : 过时的<br>asynchronously : 异步地<br>fixed target : 固定目标<br>design for failure : 面向故障设计<br>protocol : 协议<br>robustness &amp; security : 鲁棒性与安全性<br>edge cases : 边缘情况&#x2F;极端情况<br>malicious behavior : 恶意行为<br>entities : 实体，在网络语境下，它是一个抽象称谓，可以指代计算机、路由器、甚至是运行中的一个程序。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>Federated System : 联邦系统<br>ISP : 运营商<br>RFC (Request For Comments) : 互联网的“宪法”草案。</p><h2 id="什么是网络？"><a href="#什么是网络？" class="headerlink" title="什么是网络？"></a>什么是网络？</h2><p>互联网作为一种在全球设备间传输数据的工具无处不在，CS168专注于支持网络的基础设施（包括软件和硬件）。万维网和互联网不同，万维网可以看作是建立在互联网之上的应用程序，可以通过网页浏览器来访问。除了万维网，其他应用程序同样可以使用互联网基础设施。非Web应用的例子包括Zoom或在线游戏，甚至物联网（IOT）设备，比如冰箱或汽车中的传感器。</p><h2 id="为什么互联网有趣？"><a href="#为什么互联网有趣？" class="headerlink" title="为什么互联网有趣？"></a>为什么互联网有趣？</h2><p>互联网并非一种新型网络技术（例如电线早已存在），其本质创新在于解决了一个全新问题：如何将多种现有网络相互连接。解决这一问题需要一种新的设计范式，这一范式也影响了计算机科学的其他领域。计算机网络是计算机科学领域中相对较新的分支。互联网的引入带来了许多不同于传统计算机科学领域的新挑战。例如，与理论领域不同，我们缺乏互联网的形式化模型；与硬件领域不同，我们缺乏可测量的性能基准。</p><p>与以往课程不同，仅仅编写能运行的代码是不够的。编写的代码必须能扩展到数十亿用户，同时，代码还必须符合不同运营方的商业关系。</p><p>适用于轻量级应用（例如家用计算器）的代码，未必能在重型服务器上运行。今天还能正常工作的代码，随着网络节点的动态变化，到了明天也可能崩溃。互联网的设计理念深刻影响了现代系统的架构方式（例如在设计中对目标、约束和权衡的考量方式）。</p><h2 id="互联网的联邦特性"><a href="#互联网的联邦特性" class="headerlink" title="互联网的联邦特性"></a>互联网的联邦特性</h2><p>互联网的联邦特性 互联网是一个联邦式系统，要求运营商之间具备互操作性。换言之，尽管每个运营商（ISP）独立运作，但为了实现全球互联，所有运营商必须协同工作。也就是说，全球所有 ISP 都需要对某些公共协议达成一致，以实现全球连通。 联邦制带来了若干挑战。竞争实体（如竞争对手公司）被迫合作，即便他们可能并不愿彼此分享机密信息。在设计协议时，除了技术考量外，我们还必须考虑现实中的商业激励因素。 联邦制也增加了创新的难度。在其他领域，企业可以通过开发独有的新特性来创新。但在互联网领域，如果你拥有一项别人都没有的功能，你反而无法使用它。每个人都必须使用共同的语言（协议），因此互联网的任何升级都必须将互操作性考虑在内。</p><h2 id="互联网的可扩展性"><a href="#互联网的可扩展性" class="headerlink" title="互联网的可扩展性"></a>互联网的可扩展性</h2><p>联邦制使互联网实现了巨大的规模。我们无需由单一运营商管理数十亿用户和数万亿服务，而只需专注于将所有不同的运营商互联。联邦制还允许我们利用极其多样化的技术（如无线、光纤）和性能差异巨大的设备（如小容量的家庭链路或大容量的海底光缆）来构建互联网。这些技术也在不断演进，这意味着我们无法设定一个固定的目标（例如，容量和需求正以数量级的速度持续增长）。 互联网的宏大规模还意味着，我们设计的任何系统都必须支持海量的用户和应用（例如，某些应用比其他应用需要更多容量，而某些用户可能是恶意攻击者）。 互联网的全球规模要求我们的系统和协议必须异步运行。数据的传输速度不能超过光速（且通常比光速慢得多）。假设你向地球另一端的服务器发送一条消息，当消息到达时，你的 CPU 可能已经执行了数百万条额外指令，而你发送的消息可能已经过时了。 互联网的规模意味着，即便发送一条消息也可能需要与许多组件（如软件、交换机、链路）进行交互。其中任何组件都可能发生故障，而我们甚至可能无法察觉。如果确实发生了故障，可能需要很长时间才能得知这一坏消息。互联网是第一个必须针对大规模故障进行设计的系统。其中的许多理念后来被应用到了其他领域。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>在CS168中，我们将重点关注定义实体间如何进行通信交换的“协议”。这些协议规定了：它们交换的消息格式是什么？以及它们如何对这些消息做出响应？ 例如，假设你正在编写一个需要在互联网上收发数据的应用程序。发送端和接收端的代码必须就数据的格式以及针对不同消息应采取的动作达成一致。 这是一个协议示例：爱丽丝（Alice）和鲍勃（Bob）先互相打招呼，然后爱丽丝请求一个文件，鲍勃回复该文件。为了定义这一协议，我们需要确定“语法”（例如，如何用 0 和 1 来表示“给我这个文件”）和“语义”（例如，爱丽丝在请求文件之前必须先收到鲍勃的问候）。 不同的协议是为了满足不同的需求而设计的。例如，如果爱丽丝需要以最快速度获取文件，我们可能会设计一个省略初始打招呼环节的协议。设计一个优秀的协议远比想象中困难！我们还需要考虑边缘情况、程序错误以及恶意行为。例如，如果爱丽丝请求文件，而鲍勃却回复了“你好”，爱丽丝该如何反应？ 在整个课程中，我们将看到许多已在互联网上标准化的协议。当我们提及某个协议时，你有时会看到缩写 RFC（征求意见稿）。许多标准以 RFC 文档的形式发布，并最终被广泛接受，尽管并非所有 RFC 都会被采纳。RFC 文档均有编号，有时人们会直接通过编号来指代协议。例如，“RFC 1918 地址”指的就是该文档定义的特定地址。 负责协议标准化的机构各不相同。IEEE 专注于底层的电气工程领域。IETF 则专注于互联网本身，并负责 RFC 的发布。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ~~~///(^v^)&#92;&#92;&#92;~~~ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmu15-445-Porject &#92;#1-部分思路（fall2024）</title>
      <link href="/2026/01/08/cmu15-445-Porject-1-%E9%83%A8%E5%88%86%E6%80%9D%E8%B7%AF%EF%BC%88fall2024%EF%BC%89/"/>
      <url>/2026/01/08/cmu15-445-Porject-1-%E9%83%A8%E5%88%86%E6%80%9D%E8%B7%AF%EF%BC%88fall2024%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="事先声明"><a href="#事先声明" class="headerlink" title="事先声明"></a>事先声明</h1><p>按照这门课程的老师要求，不能以任何形式传播答案，因此这里只做基本的讨论，也请大家不要直接传播答案。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>事实上这个可以用虚拟机来配置，但是如果下载了docker，就可以用docker来配置（这个更加简单一点，只需要花费10分钟），建议搭配vscode。</p><h2 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> ***<br></code></pre></td></tr></table></figure><p>***就是http:&#x2F;&#x2F;或者其它格式啦(≧▽≦)。</p><h2 id="vscode-配置"><a href="#vscode-配置" class="headerlink" title="vscode 配置"></a>vscode 配置</h2><p>只需要下载拓展Dev Containers，没错，就是那个蓝色的方块(≧▽≦)，如果你喜欢，可以下载docker拓展。</p><h2 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h2><p>在根目录（比如你克隆仓库之后得到了 <code>cmu15-445</code>这个目录，点进去即可，或者说和 <code>build</code>同目录），然后创建目录 <code>.devcontainer </code>，在这个目录下面创建文件 <code>devcontainer.json </code>和 <code>Dockerfile</code>。</p><p><code>devcontainer.json</code>配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BusTub Dev Env&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;dockerfile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dockerfile&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;customizations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;vscode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;extensions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;ms-vscode.cpptools&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;ms-vscode.cmake-tools&quot;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;remoteUser&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>Dockerfile</code>配置如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-keyword">ENV</span> DEBIAN_FRONTEND=noninteractive<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span><br><span class="language-bash">    build-essential \</span><br><span class="language-bash">    cmake \</span><br><span class="language-bash">    clang-14 \</span><br><span class="language-bash">    clang-format-14 \</span><br><span class="language-bash">    clang-tidy-14 \</span><br><span class="language-bash">    gdb \</span><br><span class="language-bash">    git \</span><br><span class="language-bash">    libgtest-dev \</span><br><span class="language-bash">    libreadline-dev \</span><br><span class="language-bash">    python3 \</span><br><span class="language-bash">    zlib1g-dev \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> update-alternatives --install /usr/bin/clang clang /usr/bin/clang-14 100 &amp;&amp; \</span><br><span class="language-bash">    update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-14 100</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /bustub</span><br></code></pre></td></tr></table></figure><h2 id="最后的操作"><a href="#最后的操作" class="headerlink" title="最后的操作"></a>最后的操作</h2><p>点击vscode左下角的 <code>&gt;&lt;</code>，点击“在容器中打开文件夹”，等待大概10分钟的下载就行，如果遇到网络的问题，可以使用AI在 <code>Dockerfile</code>添加用清华源或者阿里源的语句。</p><h1 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h1><p>由于时间较长，我已经不记得这部分的思路，不过这一部分没有太多额外的 <code>cpp</code>的知识，需要注意的是 <code>std::mutex</code>的使用，在每个读和写的函数上锁住即可。</p><h1 id="Task-2-Disk-Scheduler"><a href="#Task-2-Disk-Scheduler" class="headerlink" title="Task #2 - Disk Scheduler"></a>Task #2 - Disk Scheduler</h1><h2 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a><code>std::promise</code></h2><p><code>std::promise</code>的头文件为 <code>future</code>，它像一个一次性的单槽管道。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::promise&lt;<span class="hljs-type">int</span>&gt; box;<br>std::future&lt;<span class="hljs-type">int</span>&gt; receipt = box.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">// 只能用一次get_future()</span><br><br>box.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 只能放一次</span><br><span class="hljs-type">int</span> value = receipt.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 同时也只能用一次get</span><br></code></pre></td></tr></table></figure><h2 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a><code>std::optional</code></h2><p><code>std::optional</code>的头文件为 <code>optional</code>，它像一个只有一个格子的盒子。</p><p>初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::optional&lt;<span class="hljs-type">int</span>&gt; opt_empty; <span class="hljs-comment">// 初始化为空</span><br>std::optional&lt;<span class="hljs-type">int</span>&gt; opt_value = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> opt_none = std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 明确表示为空</span><br></code></pre></td></tr></table></figure><p>检测是否有值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (opt_value.<span class="hljs-built_in">has_value</span>()) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">if</span> (opt_value) &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// 隐式转换为`bool`，最常用。</span><br></code></pre></td></tr></table></figure><p>获取值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> v1 = opt_value.<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// 如果为空，抛出 std::bad_optional_access 异常</span><br><span class="hljs-type">int</span> v2 = *opt_value; <span class="hljs-comment">// 类似于指针解引用，如果为空则为未定义。</span><br><span class="hljs-type">int</span> v3 = opt_value.<span class="hljs-built_in">value_or</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 如果为空，返回值默认为0</span><br></code></pre></td></tr></table></figure><p>值的修改和替换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::optional&lt;std::string&gt; name;<br>name.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">&quot;Bustup&quot;</span>); <span class="hljs-comment">// 原地构造，避免多余拷贝</span><br>name.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 清空内容，使其变为 nullopt</span><br></code></pre></td></tr></table></figure><h2 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a><code>Channel</code>的实现</h2><p>仅仅是建立一个临界资源的存取，这里应该是没有上限的（因为用的是队列），它是线程安全的。</p><p>使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bustup::Channel&lt;std::optional&lt;DiskRequest&gt;&gt; resquest_queue_;<br>resquest_queue_.<span class="hljs-built_in">Put</span>(); <span class="hljs-comment">// 存</span><br>resquest_queue_.<span class="hljs-built_in">Get</span>(); <span class="hljs-comment">// 放</span><br></code></pre></td></tr></table></figure><h1 id="Task-3-Buffer-Pool-Manager"><a href="#Task-3-Buffer-Pool-Manager" class="headerlink" title="Task #3 - Buffer Pool Manager"></a>Task #3 - Buffer Pool Manager</h1><h2 id="RAII-Resource-Acquisition-IS-Initialization"><a href="#RAII-Resource-Acquisition-IS-Initialization" class="headerlink" title="RAII(Resource Acquisition IS Initialization)"></a>RAII(Resource Acquisition IS Initialization)</h2><p><code>RAII</code>的核心思想是：将资源的生命周期和对象的生命周期绑定</p><ul><li>获取资源：在对象的构造函数中进行</li><li>释放资源：在对象的析构函数中自动进行</li></ul><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>移动语义允许我们将资源（如内存、所有权）从一个对象“移动”到另一个对象，而不是进行昂贵的拷贝。</p><ol><li>右值引用(T&amp;&amp;)：表示一个即将销毁的对象（临时变量）</li><li><code>std::move</code>：强制将一个左值转换为右值，从而出发移动构造函数</li></ol><p>移动构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBuffer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *data;<br>    <span class="hljs-type">size_t</span> size;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyBuffer</span>(MyBuffer&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>        : <span class="hljs-built_in">data</span>(other.data), <span class="hljs-built_in">size</span>(other.szie) &#123;<br>        other.data = <span class="hljs-literal">nullptr</span>;<br>        other.size = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RAII的简单应用"><a href="#RAII的简单应用" class="headerlink" title="RAII的简单应用"></a>RAII的简单应用</h2><p>一个简单的文件包装器，实现RAII不止于移动语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandler</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    FILE *handle;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FilerHandler</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename) &#123;<br>        handle = <span class="hljs-built_in">fopen</span>(filename, <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!handle) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;File open failed&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">FileHandler</span>() &#123;<br>        <span class="hljs-keyword">if</span> (handle) <span class="hljs-built_in">fclose</span>(handle);<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝，放置多个对象维护同一个 handle 导致重复关闭</span><br>    <span class="hljs-built_in">FileHandler</span>(<span class="hljs-type">const</span> FileHandler&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合移动语义的RAII：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceManager</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ResourceManager</span>(<span class="hljs-type">int</span> size) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Get Resource&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ResourceManager</span>() &#123;<br>        <span class="hljs-keyword">if</span> (data) &#123;<br>            <span class="hljs-keyword">delete</span>[] data;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Release Resource&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">ResourceManager</span>(ResourceManager&amp;&amp; source) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(source.data) &#123;<br>        source.data = <span class="hljs-literal">nullptr</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move Resource\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">ResourceManager</span>(<span class="hljs-type">const</span> ResourceManage&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function">ResourceManager <span class="hljs-title">createResource</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ResourceManager <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// 触发移动语义，资源从 temp 转移到调用者，没有多余的内存申请</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么说PageGuard是一个RAII对象，系统永远不需要手动对页面的读写锁进行加锁和解锁操作？"><a href="#为什么说PageGuard是一个RAII对象，系统永远不需要手动对页面的读写锁进行加锁和解锁操作？" class="headerlink" title="为什么说PageGuard是一个RAII对象，系统永远不需要手动对页面的读写锁进行加锁和解锁操作？"></a>为什么说PageGuard是一个RAII对象，系统永远不需要手动对页面的读写锁进行加锁和解锁操作？</h2><p>因为一个RAII对象必须从一开始就获取所有资源，在销毁时消除所有资源，因此在一开始就会获取锁，在离开作用域之后就会放开锁。</p><h2 id="FrameHeader"><a href="#FrameHeader" class="headerlink" title="FrameHeader"></a>FrameHeader</h2><p>包含成员变量：</p><ul><li><code>frame_id_</code> : 帧的唯一索引，是 <code>frame_id_</code>，并且是常量</li><li><code>rwlatch_</code> : 读写锁，修改时必须独占，是 <code>std::shared_mutex</code></li><li><code>pin_count_</code> : 引用计数，当前有多少个线程正在使用这个页面，是 <code>std::atomic&lt;size_t&gt;</code></li><li><code>is_dirty_</code> : 脏标记，记录内存中的数据是否被修改过，是 <code>bool</code></li><li><code>data_</code> : 实际数据存储。是一个 <code>std::vector&lt;char&gt;</code> ，大小通常是4KB</li></ul><p>方法：</p><ul><li><code>GetData()</code> : 返回指向数据的常量指针</li><li><code>GetDataMut()</code> : 返回指向数据的指针</li><li><code>Reset()</code> : 用0填充数据，强制修改 <code>pin_count_</code> 为0，<code>is_dirty_</code>设置为 <code>false</code></li></ul><h2 id="ReadPageGuard"><a href="#ReadPageGuard" class="headerlink" title="ReadPageGuard"></a>ReadPageGuard</h2><p>包含成员参数：</p><ul><li><code>page_id_</code> : 正在保护的页面号，是<code>page_id_t</code></li><li><code>frame_</code> : 保存着被保护页的帧，是<code>std::shared_ptr&lt;FrameHeader&gt;</code></li><li><code>replacer_</code> : 指向驱逐算法的共享指针，是<code>std::shared_ptr&lt;LRUKReplacer&gt;</code></li><li><code>bpm_latch_</code> : 指向缓冲池锁的共享指针，是<code>std::shared_ptr&lt;std::mutex&gt;</code></li><li><code>is_valid_</code> : 读保护的有效位，是<code>bool</code></li></ul><h2 id="WritePageGuard"><a href="#WritePageGuard" class="headerlink" title="WritePageGuard"></a>WritePageGuard</h2><p>包含成员参数：</p><ul><li><code>page_id_</code> : 正在被保护的页面号，是<code>page_id_t</code></li><li><code>frame_</code> : 保存着被保护页的帧，是<code>std::shread_ptr&lt;FrameHeader&gt;</code></li><li><code>replacer</code> : 指向驱逐算法的共享指针，是<code>std::shared_ptr&lt;LRUKReplacer&gt;</code></li><li><code>bpm_latch_</code> : 指向缓冲池锁的共享指针，是<code>std::shared_ptr&lt;std::mutex&gt;</code></li><li><code>is_valid_</code> : 读保护的有效位，是<code>bool</code></li></ul><h2 id="BufferPoolManager"><a href="#BufferPoolManager" class="headerlink" title="BufferPoolManager"></a>BufferPoolManager</h2><p>构造参数说明：</p><ul><li><code>num_frames</code> : 缓冲池大小</li><li><code>disk_manager</code> : 磁盘管理器</li><li><code>k_dist</code> : LRU-K 替换策略中的 后向 <code>k</code> 距离</li><li><code>log_manager</code> : 日志管理器</li></ul><p>包含成员变量：</p><ul><li><code>num_frames_</code> : 缓冲池大小，为<code>size_t</code></li><li><code>next_page_id</code> : 下一个待分配的页面ID，为<code>std::atomic&lt;page_id_t&gt;</code></li><li><code>bpm_latch_</code> : 缓冲池管理器互斥锁，为<code>std::shared_ptr&lt;std::mutex&gt;</code></li><li><code>frames_</code> : 帧头部集合，为<code>std::vector&lt;std::shared_ptr&lt;FrameHeader&gt;&gt;</code></li><li><code>page_table_</code> : 页表，为<code>std::unordered_map&lt;page_id_t, frame_id_t&gt;</code></li><li><code>free_frames_</code> : 空闲帧集合，为<code>std::list&lt;frame_id_t&gt;</code></li><li><code>replacer_</code> : 置换器，这里是 LRU-K 算法，为<code>std::shared_ptr&lt;LRUKReplacer&gt;</code></li><li><code>disk_scheduler_</code> : 磁盘调度器，为<code>std::unique_ptr&lt;DiskScheduler&gt;</code></li><li><code>log_manager</code> : 日志管理器，为<code>LogManager *</code></li></ul><h2 id="移动赋值运算符需要注意的地方"><a href="#移动赋值运算符需要注意的地方" class="headerlink" title="移动赋值运算符需要注意的地方"></a>移动赋值运算符需要注意的地方</h2><p>它不同于移动构造函数，需要注意清理自身存在的，毕竟它不像移动构造函数开始时一定为空。</p><h2 id="关于IsDirtyTest"><a href="#关于IsDirtyTest" class="headerlink" title="关于IsDirtyTest"></a>关于IsDirtyTest</h2><p>注意WritePageGuard在创建的时候就是脏了，因此判断帧不为空之后就将 <code>is_dirty_</code> 赋值为true。</p><h2 id="关于SchedulerTest"><a href="#关于SchedulerTest" class="headerlink" title="关于SchedulerTest"></a>关于SchedulerTest</h2><p>这个实在是没搞懂</p>]]></content>
      
      
      
        <tags>
            
            <tag> (●&#39;◡&#39;●) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
